<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Digital Twin Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Tandem Viewer CSS -->
  <link href="https://static.tandem.autodesk.com/1.0.605/style.css" rel="stylesheet" type="text/css">
  <style>
    :root {
      --sidebar-bg: #222428;
      --sidebar-active: #2d3748;
      --sidebar-text: #bfc3ce;
      --sidebar-title: #fff;
      --main-bg: #141517;
      --card-bg: #23262b;
      --card-border: #292c31;
      --card-title: #bfc3ce;
      --card-value: #49a6ff;
      --card-desc: #8fa0b2;
      --header-bg: #191b1f;
      --header-title: #61b0ff;
      --btn-bg: #2d3748;
      --btn-text: #fff;
      --btn-active: #49a6ff;
      --btn-success: #28a745;
      --btn-warning: #ffc107;
      --btn-danger: #dc3545;
      --divider: #363941;
      --scrollbar: #333;
      --accent: #6c5ecb;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--main-bg);
      color: #fff;
      font-family: 'Segoe UI', 'Malgun Gothic', Arial, sans-serif;
    }
    
    body {
      height: 100vh;
      display: flex;
      flex-direction: column;
      min-width: 1200px;
      overflow: hidden;
    }
    
    /* 상단 헤더 */
    .header {
      width: 100%;
      height: 56px;
      background: var(--header-bg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 32px;
      box-sizing: border-box;
      border-bottom: 1px solid var(--divider);
      z-index: 10;
    }
    
    .header-title {
      font-size: 1.4em;
      font-weight: 700;
      color: var(--header-title);
      letter-spacing: 1px;
      display: flex;
      align-items: center;
    }
    
    .header-title span {
      color: #49a6ff;
      margin-right: 8px;
      font-size: 1.2em;
      font-weight: 900;
    }
    
    .header-menu {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .header-btn {
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .header-btn:hover {
      background: var(--btn-active);
    }
    
    .header-btn.active {
      background: var(--btn-success);
      color: #fff;
    }
    
    .header-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #dc3545;
      display: inline-block;
      margin-right: 6px;
      animation: pulse 2s infinite;
    }
    
    .status-indicator.connected {
      background: #28a745;
      animation: none;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* 전체 레이아웃 */
    .dashboard-layout {
      display: flex;
      flex: 1 1 auto;
      height: calc(100vh - 56px);
      min-height: 0;
    }
    
    /* 좌측 사이드바 */
    .sidebar {
      width: 320px;
      background: var(--sidebar-bg);
      display: flex;
      flex-direction: column;
      padding: 24px 0;
      box-sizing: border-box;
      border-right: 1px solid var(--divider);
      overflow-y: auto;
    }
    
    .sidebar-section {
      margin-bottom: 24px;
    }
    
    .sidebar-section-title {
      font-size: 1.05em;
      color: var(--sidebar-title);
      margin: 0 0 12px 24px;
      font-weight: 700;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-right: 24px;
    }
    
    .sidebar-dropdown {
      margin: 0 16px 16px 16px;
    }
    
    .sidebar-dropdown select {
      width: 100%;
      background: var(--card-bg);
      color: var(--sidebar-text);
      border: 1px solid var(--card-border);
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 0.95em;
      cursor: pointer;
      outline: none;
    }
    
    .sidebar-dropdown select:focus {
      border-color: var(--btn-active);
    }
    
    .sidebar-dropdown label {
      display: block;
      font-size: 0.9em;
      color: var(--sidebar-text);
      margin-bottom: 6px;
      font-weight: 500;
    }
    
    .load-btn {
      background: var(--btn-active);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      margin: 16px;
      transition: all 0.2s;
    }
    
    .load-btn:hover {
      background: #3d8bfd;
    }
    
    .load-btn:disabled {
      background: var(--btn-bg);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* 중앙 컨텐츠 */
    .main-content {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at center, #23262b 0%, #141517 100%);
      position: relative;
    }
    
    /* 페이지 컨테이너 */
    .page-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .page-content {
      width: 100%;
      height: 100%;
      display: none;
    }
    
    .page-content.active {
      display: block;
    }
    
    /* Tandem Viewer 컨테이너 */
    #tandem-viewer-container {
      width: 100%;
      height: 100%;
      display: none;
    }
    
    /* 초기 화면 */
    .center-content {
      text-align: center;
      color: #bfc3ce;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 320px;
    }
    
    .viewer-icon {
      width: 92px;
      height: 92px;
      margin-bottom: 18px;
      border-radius: 24px;
      background: linear-gradient(135deg, #5ecbff 0%, #6c5ecb 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3.4em;
      color: #fff;
      box-shadow: 0 2px 12px rgba(80,120,255,0.12);
    }
    
    .viewer-title {
      font-size: 1.3em;
      font-weight: 700;
      margin-bottom: 10px;
      color: #fff;
    }
    
    .viewer-desc {
      color: #bfc3ce;
      font-size: 1.08em;
      margin-bottom: 0;
      line-height: 1.4;
    }
    
    /* 로딩 오버레이 */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 21, 23, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .loading-content {
      text-align: center;
      color: #bfc3ce;
    }
    
    .loading-spinner {
      border: 3px solid #333;
      border-top: 3px solid #49a6ff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-size: 1.1em;
      margin-bottom: 8px;
    }
    
    .loading-progress {
      font-size: 0.9em;
      color: #8fa0b2;
    }
    
    /* 우측 실시간 데이터 카드 */
    .right-panel {
      width: 320px;
      background: none;
      padding: 32px 16px 32px 0;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      z-index: 2;
    }
    
    .realtime-card {
      width: 100%;
      background: var(--card-bg);
      border-radius: 18px;
      box-shadow: 0 4px 18px rgba(30,60,120,0.12);
      padding: 20px 18px 20px 24px;
      box-sizing: border-box;
      border: 1px solid var(--card-border);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    
    .realtime-title {
      font-size: 1.14em;
      color: #fff;
      font-weight: 700;
      margin-bottom: 8px;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .realtime-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    
    .realtime-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .realtime-label {
      color: #bfc3ce;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 7px;
      font-weight: 500;
    }
    
    .realtime-value {
      color: var(--card-value);
      font-size: 1.25em;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .realtime-value.door-open {
      color: #ff6b6b;
      animation: doorAlert 1s infinite;
    }
    
    .realtime-value.door-closed {
      color: #28a745;
    }
    
    @keyframes doorAlert {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .realtime-desc {
      color: var(--card-desc);
      font-size: 0.96em;
      margin-left: 28px;
      margin-top: 2px;
    }
    
    .realtime-icon {
      font-size: 1.15em;
      margin-right: 5px;
    }
    
    /* 문 모니터링 카드 */
    .door-monitoring-card {
      width: 100%;
      background: var(--card-bg);
      border-radius: 18px;
      box-shadow: 0 4px 18px rgba(30,60,120,0.12);
      padding: 20px 18px 20px 24px;
      box-sizing: border-box;
      border: 1px solid var(--card-border);
      margin-bottom: 20px;
    }
    
    .door-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .door-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      transition: all 0.3s;
    }
    
    .door-item.open {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid rgba(255, 107, 107, 0.4);
    }
    
    .door-item.closed {
      background: rgba(40, 167, 69, 0.2);
      border: 1px solid rgba(40, 167, 69, 0.4);
    }
    
    .door-name {
      font-weight: 600;
      color: #fff;
    }
    
    .door-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .door-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #28a745;
    }
    
    .door-indicator.open {
      background: #ff6b6b;
      animation: pulse 2s infinite;
    }
    
    .door-actions {
      display: flex;
      gap: 4px;
    }
    
    .door-action-btn {
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .door-action-btn:hover {
      background: var(--btn-active);
    }
    
    /* 통계 페이지 스타일 */
    .statistics-page {
      padding: 20px;
      overflow-y: auto;
      height: 100%;
    }
    
    .stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--divider);
    }
    
    .stats-title {
      font-size: 2em;
      font-weight: 700;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .stats-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    .date-selector {
      background: var(--card-bg);
      color: var(--sidebar-text);
      border: 1px solid var(--card-border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 0.9em;
      cursor: pointer;
      outline: none;
    }
    
    .refresh-btn {
      background: var(--btn-active);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 0.9em;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .refresh-btn:hover {
      background: #3d8bfd;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid var(--card-border);
      box-shadow: 0 4px 18px rgba(30,60,120,0.12);
    }
    
    .stat-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .stat-card-title {
      font-size: 1.1em;
      font-weight: 600;
      color: #fff;
    }
    
    .stat-card-icon {
      font-size: 1.5em;
      color: var(--card-value);
    }
    
    .stat-value {
      font-size: 2.5em;
      font-weight: 700;
      color: var(--card-value);
      margin-bottom: 8px;
    }
    
    .stat-description {
      color: var(--card-desc);
      font-size: 0.9em;
      margin-bottom: 16px;
    }
    
    .stat-trend {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
    }
    
    .trend-up {
      color: #28a745;
    }
    
    .trend-down {
      color: #dc3545;
    }
    
    .trend-neutral {
      color: #ffc107;
    }
    
    .chart-container {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid var(--card-border);
      margin-bottom: 20px;
      box-shadow: 0 4px 18px rgba(30,60,120,0.12);
    }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .chart-title {
      font-size: 1.3em;
      font-weight: 600;
      color: #fff;
    }
    
    .chart-controls {
      display: flex;
      gap: 8px;
    }
    
    .chart-btn {
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .chart-btn:hover {
      background: var(--btn-active);
    }
    
    .chart-btn.active {
      background: var(--btn-active);
    }
    
    .chart-canvas {
      width: 100%;
      height: 300px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      margin-top: 10px;
    }
    
    /* 에러/성공 메시지 */
    .message {
      padding: 12px 20px;
      border-radius: 8px;
      margin: 16px;
      text-align: center;
      display: none;
      font-weight: 500;
    }
    
    .error-message {
      background: #dc3545;
      color: white;
      border: 1px solid #c82333;
    }
    
    .success-message {
      background: #28a745;
      color: white;
      border: 1px solid #1e7e34;
    }
    
    .info-message {
      background: #17a2b8;
      color: white;
      border: 1px solid #138496;
    }
    
    /* 스크롤바 */
    ::-webkit-scrollbar { 
      width: 7px; 
      background: var(--sidebar-bg);
    }
    ::-webkit-scrollbar-thumb { 
      background: var(--scrollbar); 
      border-radius: 7px;
    }
    ::selection { 
      background: #49a6ff33; 
    }
    
    /* 반응형 */
    @media (max-width: 1400px) {
      .sidebar { width: 280px; }
      .right-panel { width: 280px; }
    }
    
    @media (max-width: 1200px) {
      .sidebar { width: 200px; }
      .right-panel { width: 220px; }
    }
    
    @media (max-width: 900px) {
      .sidebar { display: none; }
      .right-panel { display: none; }
      .main-content { flex: 1 1 auto; }
    }
  </style>
</head>
<body>
  <!-- 상단 헤더 -->
  <div class="header">
    <div class="header-title">
      <span>🏗️</span> Digital Twin Dashboard
    </div>
    <div class="header-menu">
      <button class="header-btn" onclick="showPage('viewer')">
        3D 뷰어
      </button>
      <button class="header-btn" onclick="showPage('statistics')">
        📊 통계
      </button>
      <button class="header-btn" onclick="openGoogleSheetsConfig()">
        🔗 API 설정
      </button>
      <button class="header-btn" id="connect-btn" onclick="initializeTandem()">
        <span class="status-indicator" id="status-indicator"></span>
        <span id="connect-text">Tandem 연결</span>
      </button>
      <button class="header-btn" id="sheets-status" style="opacity: 0.7;">
        <span class="status-indicator" id="sheets-indicator"></span>
        <span id="sheets-text">Sheets 미연결</span>
      </button>
    </div>
  </div>
  
  <!-- 메시지 영역 -->
  <div class="error-message message" id="error-message"></div>
  <div class="success-message message" id="success-message"></div>
  <div class="info-message message" id="info-message"></div>
  
  <div class="dashboard-layout">
    <!-- 좌측 사이드바 -->
    <div class="sidebar">
      <!-- 팀 선택 -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">팀 선택</div>
        <div class="sidebar-dropdown">
          <label for="team-select">팀:</label>
          <select id="team-select" onchange="onTeamChange()" disabled>
            <option value="">연결 후 선택 가능</option>
          </select>
        </div>
      </div>
      
      <!-- 시설 선택 -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">시설 선택</div>
        <div class="sidebar-dropdown">
          <label for="facility-select">시설:</label>
          <select id="facility-select" onchange="onFacilityChange()" disabled>
            <option value="">팀 선택 후 표시</option>
          </select>
        </div>
      </div>
      
      <!-- 뷰 선택 -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">뷰 선택</div>
        <div class="sidebar-dropdown">
          <label for="view-select">뷰:</label>
          <select id="view-select" onchange="onViewChange()" disabled>
            <option value="">시설 선택 후 표시</option>
          </select>
        </div>
        <button class="load-btn" id="load-btn" onclick="loadSelectedView()" disabled>
          선택된 뷰 로드
        </button>
      </div>
      
      <!-- 직접 URN 로드 -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">직접 URN 로드</div>
        <div class="sidebar-dropdown">
          <label for="urn-input">Facility URN:</label>
          <input type="text" id="urn-input" placeholder="urn:adsk.dtt:..." 
                 style="width: 100%; background: var(--card-bg); color: var(--sidebar-text); 
                        border: 1px solid var(--card-border); border-radius: 6px; 
                        padding: 8px 12px; font-size: 0.9em; margin-bottom: 8px;">
          <label for="view-id-input">View ID (선택사항):</label>
          <input type="text" id="view-id-input" placeholder="view-id" 
                 style="width: 100%; background: var(--card-bg); color: var(--sidebar-text); 
                        border: 1px solid var(--card-border); border-radius: 6px; 
                        padding: 8px 12px; font-size: 0.9em; margin-bottom: 12px;">
          <button class="load-btn" onclick="loadDirectURN()" style="margin: 0; width: 100%;">
            URN으로 로드
          </button>
        </div>
      </div>
    </div>
    
    <!-- 중앙 컨텐츠 -->
    <div class="main-content">
      <div class="page-container">
        <!-- 3D 뷰어 페이지 -->
        <div id="viewer-page" class="page-content active">
          <!-- 로딩 오버레이 -->
          <div class="loading-overlay" id="loading-overlay">
            <div class="loading-content">
              <div class="loading-spinner"></div>
              <div class="loading-text" id="loading-text">Tandem Viewer 초기화 중...</div>
              <div class="loading-progress" id="loading-progress"></div>
            </div>
          </div>
          
          <!-- 초기 화면 -->
          <div class="center-content" id="initial-content">
            <div class="viewer-icon">
              <span style="font-size:2.6em;">🏢</span>
            </div>
            <div class="viewer-title">Autodesk Tandem Viewer</div>
            <div class="viewer-desc">
              상단의 'Tandem 연결' 버튼을 클릭하여 시작하세요<br>
              <small>팀 → 시설 → 뷰 순서로 선택하거나 직접 URN으로 로드할 수 있습니다</small><br>
              <small style="color: #8fa0b2;">단축키: Ctrl+T (연결), Ctrl+F (전체 활성화), Ctrl+R (필터 새로고침)</small>
            </div>
          </div>
          
          <!-- Tandem Viewer 컨테이너 -->
          <div id="tandem-viewer-container"></div>
        </div>

        <!-- 통계 페이지 -->
        <div id="statistics-page" class="page-content statistics-page">
          <div class="stats-header">
            <div class="stats-title">
              📊 시설 통계 대시보드
            </div>
            <div class="stats-controls">
              <select class="date-selector" id="date-range-select">
                <option value="today">오늘</option>
                <option value="week" selected>이번 주</option>
                <option value="month">이번 달</option>
                <option value="year">올해</option>
              </select>
              <button class="refresh-btn" onclick="refreshStatistics()">
                🔄 새로고침
              </button>
            </div>
          </div>

          <!-- 주요 지표 카드들 -->
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-card-header">
                <span class="stat-card-title">평균 온도</span>
                <span class="stat-card-icon">🌡️</span>
              </div>
              <div class="stat-value" id="avg-temp">23.5°C</div>
              <div class="stat-description">지난 주 대비</div>
              <div class="stat-trend">
                <span class="trend-up">▲ 2.3°C</span>
                <span>상승</span>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-card-header">
                <span class="stat-card-title">평균 습도</span>
                <span class="stat-card-icon">💧</span>
              </div>
              <div class="stat-value" id="avg-humidity">58%</div>
              <div class="stat-description">지난 주 대비</div>
              <div class="stat-trend">
                <span class="trend-down">▼ 3%</span>
                <span>감소</span>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-card-header">
                <span class="stat-card-title">총 에너지 소비</span>
                <span class="stat-card-icon">⚡</span>
              </div>
              <div class="stat-value" id="total-energy">1,247 kWh</div>
              <div class="stat-description">지난 주 대비</div>
              <div class="stat-trend">
                <span class="trend-neutral">→ 0.5%</span>
                <span>유지</span>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-card-header">
                <span class="stat-card-title">문 개폐 횟수</span>
                <span class="stat-card-icon">🚪</span>
              </div>
              <div class="stat-value" id="door-events">156</div>
              <div class="stat-description">지난 주 대비</div>
              <div class="stat-trend">
                <span class="trend-up">▲ 12</span>
                <span>증가</span>
              </div>
            </div>
          </div>

          <!-- 차트 섹션 -->
          <div class="chart-container">
            <div class="chart-header">
              <span class="chart-title">온도 변화 추이</span>
              <div class="chart-controls">
                <button class="chart-btn active" onclick="setChartPeriod('temperature', 'day')">일간</button>
                <button class="chart-btn" onclick="setChartPeriod('temperature', 'week')">주간</button>
                <button class="chart-btn" onclick="setChartPeriod('temperature', 'month')">월간</button>
              </div>
            </div>
            <canvas id="temperature-chart" class="chart-canvas"></canvas>
          </div>

          <div class="chart-container">
            <div class="chart-header">
              <span class="chart-title">에너지 소비량</span>
              <div class="chart-controls">
                <button class="chart-btn active" onclick="setChartPeriod('energy', 'day')">일간</button>
                <button class="chart-btn" onclick="setChartPeriod('energy', 'week')">주간</button>
                <button class="chart-btn" onclick="setChartPeriod('energy', 'month')">월간</button>
              </div>
            </div>
            <canvas id="energy-chart" class="chart-canvas"></canvas>
          </div>

          <div class="chart-container">
            <div class="chart-header">
              <span class="chart-title">문 상태 모니터링</span>
              <div class="chart-controls">
                <button class="chart-btn active" onclick="setChartPeriod('doors', 'realtime')">실시간</button>
                <button class="chart-btn" onclick="setChartPeriod('doors', 'day')">일간</button>
              </div>
            </div>
            <canvas id="doors-chart" class="chart-canvas"></canvas>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 우측 패널들 -->
    <div class="right-panel">
      <!-- 문 모니터링 카드 -->
      <div class="door-monitoring-card">
        <div class="realtime-title">문 상태 모니터링</div>
        <div class="door-list" id="door-list">
          <!-- 문 목록이 여기에 동적으로 추가됩니다 -->
        </div>
      </div>
      
      <!-- 실시간 데이터 -->
      <div class="realtime-card">
        <div class="realtime-title">실시간 데이터</div>
        <ul class="realtime-list">
          <li class="realtime-item">
            <span class="realtime-label">
              <span class="realtime-icon">🌡️</span>온도
            </span>
            <span class="realtime-value" id="temp-value">--</span>
          </li>
          <li class="realtime-desc" id="temp-desc"></li>
          
          <li class="realtime-item">
            <span class="realtime-label">
              <span class="realtime-icon">💧</span>습도
            </span>
            <span class="realtime-value" id="hum-value">--</span>
          </li>
          <li class="realtime-desc" id="hum-desc"></li>
          
          <li class="realtime-item">
            <span class="realtime-label">
              <span class="realtime-icon">⚡</span>에너지
            </span>
            <span class="realtime-value" id="energy-value">--</span>
          </li>
          <li class="realtime-desc" id="energy-desc"></li>
          
          <li class="realtime-item">
            <span class="realtime-label">
              <span class="realtime-icon">💡</span>조도
            </span>
            <span class="realtime-value" id="illumin-value">--</span>
          </li>
          <li class="realtime-desc" id="illumin-desc"></li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Tandem Viewer JavaScript -->
  <script src="https://static.tandem.autodesk.com/1.0.605/viewer3D.js"></script>
  <!-- Chart.js for statistics -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  
  <script>
    // ====== 사용자 설정 부분 ======
    
    // TODO: 서버 환경에서는 이 값들을 제거하고 /api/auth/token API를 사용하세요
    // 클라이언트 전용 개발 시에만 사용 (프로덕션에서는 보안상 권장하지 않음)
    const APS_CLIENT_ID = "YOUR_CLIENT_ID_HERE";
    const APS_CLIENT_SECRET = "YOUR_CLIENT_SECRET_HERE";
    
    // 서버 API 사용 여부 (true: 서버 API 사용, false: 클라이언트 직접 인증)
    const USE_SERVER_API = false;
    
    // ===============================
    
    // 전역 변수
    let tandemApp = null;
    let viewer = null;
    let isConnected = false;
    let currentPage = 'viewer';
    let doors = [];
    let charts = {};
    let previousDoorStates = {};
    let doorMarkers = [];
    let isGoogleSheetsConnected = false;
    let dataLogInterval = null;
    
    // 문 정보 (실제 시설에서는 API나 Tandem에서 가져와야 함)
    const doorConfig = [
      { id: 'door1', name: '정문', position: [0, 0, 0], status: 'closed', dbId: 100 },
      { id: 'door2', name: '비상문', position: [10, 0, 0], status: 'closed', dbId: 101 },
      { id: 'door3', name: '화장실문', position: [-5, 5, 0], status: 'closed', dbId: 102 },
      { id: 'door4', name: '회의실문', position: [5, 10, 0], status: 'closed', dbId: 103 }
    ];
    
    // Google Sheets API 설정
    let googleSheetsConfig = {
      apiKey: '',
      spreadsheetId: '',
      sheetName: '데이터',
      isConnected: false
    };
    
    // Google Sheets API 설정 페이지 열기
    function openGoogleSheetsConfig() {
      window.open('google-sheets-config.html', '_blank', 'width=1200,height=800');
    }
    
    // Google Sheets API 초기화
    async function initGoogleSheets() {
      try {
        const saved = localStorage.getItem('googleSheetsConfig');
        if (saved) {
          const config = JSON.parse(saved);
          googleSheetsConfig = { ...googleSheetsConfig, ...config };
          
          if (googleSheetsConfig.apiKey && googleSheetsConfig.spreadsheetId) {
            // 간단한 연결 테스트
            const testUrl = `https://sheets.googleapis.com/v4/spreadsheets/${googleSheetsConfig.spreadsheetId}?key=${googleSheetsConfig.apiKey}`;
            const response = await fetch(testUrl);
            
            if (response.ok) {
              isGoogleSheetsConnected = true;
              updateGoogleSheetsStatus(true);
              startDataLogging();
              console.log('Google Sheets 연결 성공');
            } else {
              updateGoogleSheetsStatus(false);
            }
          }
        }
      } catch (error) {
        console.error('Google Sheets 초기화 실패:', error);
        updateGoogleSheetsStatus(false);
      }
    }
    
    // Google Sheets 상태 업데이트
    function updateGoogleSheetsStatus(connected) {
      const btn = document.getElementById('sheets-status');
      const indicator = document.getElementById('sheets-indicator');
      const text = document.getElementById('sheets-text');
      
      if (connected) {
        btn.style.opacity = '1';
        btn.classList.add('active');
        indicator.classList.add('connected');
        text.textContent = 'Sheets 연결됨';
        isGoogleSheetsConnected = true;
      } else {
        btn.style.opacity = '0.7';
        btn.classList.remove('active');
        indicator.classList.remove('connected');
        text.textContent = 'Sheets 미연결';
        isGoogleSheetsConnected = false;
      }
    }
    
    // 데이터 로깅 시작
    function startDataLogging() {
      if (dataLogInterval) {
        clearInterval(dataLogInterval);
      }
      
      // 5분마다 데이터 로깅
      dataLogInterval = setInterval(logDataToGoogleSheets, 5 * 60 * 1000);
      
      // 즉시 한 번 실행
      logDataToGoogleSheets();
    }
    
    // Google Sheets에 데이터 로깅
    async function logDataToGoogleSheets() {
      if (!isGoogleSheetsConnected) return;
      
      try {
        const now = new Date();
        const data = {
          timestamp: now.toISOString(),
          temperature: parseFloat(document.getElementById('temp-value').textContent.replace('°C', '')) || 0,
          humidity: parseFloat(document.getElementById('hum-value').textContent.replace('%', '')) || 0,
          energy: parseFloat(document.getElementById('energy-value').textContent.replace('kWh', '')) || 0,
          door_events: doors.filter(d => d.status === 'open').length,
          illumination: parseFloat(document.getElementById('illumin-value').textContent.replace('lux', '')) || 0
        };
        
        // 실제 Google Sheets API 호출 (간단화된 버전)
        const values = [[
          data.timestamp,
          data.temperature,
          data.humidity,
          data.energy,
          data.door_events,
          data.illumination
        ]];
        
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${googleSheetsConfig.spreadsheetId}/values/${googleSheetsConfig.sheetName}:append?valueInputOption=RAW&key=${googleSheetsConfig.apiKey}`;
        
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            values: values
          })
        });
        
        if (response.ok) {
          console.log('데이터가 Google Sheets에 기록되었습니다:', data);
        }
        
      } catch (error) {
        console.error('Google Sheets 데이터 로깅 실패:', error);
      }
    }
    
    // 문 상태 초기화 (개선된 버전)
    function initializeDoors() {
      doors = doorConfig.map(door => ({ ...door }));
      
      // 이전 상태 저장
      doors.forEach(door => {
        previousDoorStates[door.id] = door.status;
      });
      
      updateDoorDisplay();
    }
    
    // 문 상태 변화 감지 및 처리 (개선된 버전)
    function checkDoorStateChanges() {
      doors.forEach(door => {
        const previousState = previousDoorStates[door.id];
        
        if (previousState !== door.status) {
          // 상태 변화 감지
          if (door.status === 'open') {
            handleDoorOpened(door);
          } else {
            handleDoorClosed(door);
          }
          
          // 상태 업데이트
          previousDoorStates[door.id] = door.status;
          
          // Google Sheets에 이벤트 로깅
          if (isGoogleSheetsConnected) {
            logDoorEventToGoogleSheets(door);
          }
        }
      });
    }
    
    // 문이 열렸을 때 처리 (개선된 버전)
    function handleDoorOpened(door) {
      // 경고 표시 (더 강조된 메시지)
      showError(`🚨 ${door.name}이 열렸습니다!`);
      
      // 3D 뷰어에서 해당 문으로 카메라 이동
      if (viewer && viewer.model && currentPage === 'viewer') {
        focusOnDoor(door.id);
      }
      
      // 문 색상 변경 및 마커 표시
      highlightDoorInViewer(door, true);
      
      // 사운드 알림 (옵션)
      playNotificationSound();
      
      // 브라우저 알림 (권한이 있는 경우)
      if (Notification.permission === 'granted') {
        new Notification('문 열림 감지', {
          body: `${door.name}이 열렸습니다.`,
          icon: '🚪'
        });
      }
    }
    
    // 문이 닫혔을 때 처리
    function handleDoorClosed(door) {
      showSuccess(`${door.name}이 닫혔습니다.`);
      highlightDoorInViewer(door, false);
    }
    
    // Google Sheets에 문 이벤트 로깅
    async function logDoorEventToGoogleSheets(door) {
      if (!isGoogleSheetsConnected) return;
      
      try {
        const event = {
          timestamp: new Date().toISOString(),
          door_id: door.id,
          door_name: door.name,
          action: door.status,
          position: door.position.join(',')
        };
        
        // 별도의 이벤트 시트에 기록 (있는 경우)
        const eventSheetName = '문이벤트';
        const values = [[
          event.timestamp,
          event.door_id,
          event.door_name,
          event.action,
          event.position
        ]];
        
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${googleSheetsConfig.spreadsheetId}/values/${eventSheetName}:append?valueInputOption=RAW&key=${googleSheetsConfig.apiKey}`;
        
        await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            values: values
          })
        });
        
        console.log('문 이벤트가 Google Sheets에 기록되었습니다:', event);
        
      } catch (error) {
        console.error('문 이벤트 로깅 실패:', error);
      }
    }
    
    // 3D 뷰어에서 문에 포커스 (개선된 버전)
    function focusOnDoor(doorId) {
      const door = doors.find(d => d.id === doorId);
      if (!door || !viewer) return;
      
      try {
        if (door.dbId && viewer.model) {
          // 실제 3D 요소가 있는 경우
          viewer.select([door.dbId]);
          viewer.fitToView([door.dbId]);
          
          // 카메라 애니메이션
          setTimeout(() => {
            const position = door.position;
            const target = new THREE.Vector3(position[0], position[1], position[2]);
            const camera = new THREE.Vector3(position[0] + 5, position[1] + 5, position[2] + 5);
            
            viewer.navigation.setView(camera, target);
          }, 500);
          
        } else {
          // dbId가 없는 경우 좌표로 이동
          const position = door.position;
          const target = new THREE.Vector3(position[0], position[1], position[2]);
          const camera = new THREE.Vector3(position[0] + 5, position[1] + 5, position[2] + 5);
          
          viewer.navigation.setView(camera, target);
        }
        
        showInfo(`${door.name}으로 카메라가 이동했습니다.`);
        
      } catch (error) {
        console.error('카메라 이동 실패:', error);
        showError('카메라 이동 중 오류가 발생했습니다.');
      }
    }
    
    // 3D 뷰어에서 문 하이라이트 (개선된 버전)
    function highlightDoorInViewer(door, isOpen) {
      if (!viewer || !viewer.model) return;
      
      try {
        if (door.dbId) {
          // 실제 3D 요소의 색상 변경
          const color = isOpen ? new THREE.Color(1, 0, 0) : null; // 빨간색 또는 기본색
          
          if (isOpen) {
            // 문을 빨간색으로 하이라이트
            viewer.setThemingColor(door.dbId, color);
          } else {
            // 하이라이트 제거
            viewer.clearThemingColors(door.dbId);
          }
        }
        
        // 마커 추가/제거
        if (isOpen) {
          addDoorMarker(door);
        } else {
          removeDoorMarker(door.id);
        }
        
      } catch (error) {
        console.error('문 하이라이트 실패:', error);
      }
    }
    
    // 문 마커 추가
    function addDoorMarker(door) {
      try {
        // 기존 마커 제거
        removeDoorMarker(door.id);
        
        // 새 마커 생성 (간단한 3D 스프라이트)
        const markerGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const markerMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          transparent: true,
          opacity: 0.8
        });
        
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.set(door.position[0], door.position[1], door.position[2] + 3);
        
        // 마커 애니메이션
        const animate = () => {
          marker.position.z += Math.sin(Date.now() * 0.005) * 0.1;
          requestAnimationFrame(animate);
        };
        animate();
        
        // 뷰어에 마커 추가
        if (viewer.impl && viewer.impl.scene) {
          viewer.impl.scene.add(marker);
          doorMarkers.push({ id: door.id, marker: marker });
          viewer.impl.invalidate(true);
        }
        
      } catch (error) {
        console.error('마커 추가 실패:', error);
      }
    }
    
    // 문 마커 제거
    function removeDoorMarker(doorId) {
      try {
        const markerIndex = doorMarkers.findIndex(m => m.id === doorId);
        if (markerIndex !== -1) {
          const markerObj = doorMarkers[markerIndex];
          
          if (viewer.impl && viewer.impl.scene) {
            viewer.impl.scene.remove(markerObj.marker);
            viewer.impl.invalidate(true);
          }
          
          doorMarkers.splice(markerIndex, 1);
        }
      } catch (error) {
        console.error('마커 제거 실패:', error);
      }
    }
    
    // 알림 사운드 재생
    function playNotificationSound() {
      try {
        // 간단한 비프 사운드 생성
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
        
      } catch (error) {
        console.error('사운드 재생 실패:', error);
      }
    }
    function showPage(pageName) {
      const pages = document.querySelectorAll('.page-content');
      pages.forEach(page => page.classList.remove('active'));
      
      const targetPage = document.getElementById(`${pageName}-page`);
      if (targetPage) {
        targetPage.classList.add('active');
        currentPage = pageName;
        
        // 통계 페이지로 전환 시 차트 초기화
        if (pageName === 'statistics') {
          setTimeout(() => {
            initializeCharts();
            refreshStatistics();
          }, 100);
        }
      }
      
      // 헤더 버튼 활성화 상태 업데이트
      const headerBtns = document.querySelectorAll('.header-btn');
      headerBtns.forEach(btn => btn.classList.remove('active'));
      
      if (pageName === 'viewer') {
        headerBtns[0].classList.add('active');
      } else if (pageName === 'statistics') {
        headerBtns[1].classList.add('active');
      }
    }
    
    // 문 상태 초기화
    function initializeDoors() {
      doors = [...doorConfig];
      updateDoorDisplay();
    }
    
    // 문 상태 표시 업데이트
    function updateDoorDisplay() {
      const doorList = document.getElementById('door-list');
      doorList.innerHTML = '';
      
      doors.forEach(door => {
        const doorItem = document.createElement('div');
        doorItem.className = `door-item ${door.status}`;
        doorItem.innerHTML = `
          <div class="door-name">${door.name}</div>
          <div class="door-status">
            <span class="door-indicator ${door.status}"></span>
            <span>${door.status === 'open' ? '열림' : '닫힘'}</span>
            <div class="door-actions">
              <button class="door-action-btn" onclick="focusOnDoor('${door.id}')">보기</button>
              <button class="door-action-btn" onclick="toggleDoor('${door.id}')">
                ${door.status === 'open' ? '닫기' : '열기'}
              </button>
            </div>
          </div>
        `;
        doorList.appendChild(doorItem);
      });
    }
    
    // 문 상태 토글 (개선된 버전)
    function toggleDoor(doorId) {
      const door = doors.find(d => d.id === doorId);
      if (door) {
        door.status = door.status === 'open' ? 'closed' : 'open';
        
        // 상태 변화 체크 및 처리
        checkDoorStateChanges();
        
        // 디스플레이 업데이트
        updateDoorDisplay();
        
        // 통계 차트 업데이트 (문 상태가 변경된 경우)
        if (currentPage === 'statistics' && charts.doors) {
          charts.doors.data.datasets[0].data = [
            doors.filter(d => d.status === 'open').length,
            doors.filter(d => d.status === 'closed').length
          ];
          charts.doors.update();
        }
      }
    }
    
    // 문이 열렸을 때 처리
    function handleDoorOpened(door) {
      // 경고 표시
      showInfo(`${door.name}이 열렸습니다!`);
      
      // 3D 뷰어에서 해당 문으로 카메라 이동 (Tandem이 연결된 경우)
      if (viewer && viewer.model) {
        focusOnDoor(door.id);
      }
      
      // 문 색상 변경 및 마커 표시
      highlightDoorInViewer(door);
    }
    
    // 3D 뷰어에서 문에 포커스
    function focusOnDoor(doorId) {
      const door = doors.find(d => d.id === doorId);
      if (!door || !viewer) return;
      
      try {
        // 카메라를 해당 문 위치로 이동
        const position = door.position;
        const target = new THREE.Vector3(position[0], position[1], position[2]);
        const camera = new THREE.Vector3(position[0] + 5, position[1] + 5, position[2] + 5);
        
        viewer.navigation.setView(camera, target);
        showInfo(`${door.name}으로 이동했습니다.`);
      } catch (error) {
        console.error('카메라 이동 실패:', error);
      }
    }
    
    // 3D 뷰어에서 문 하이라이트
    function highlightDoorInViewer(door) {
      if (!viewer || !viewer.model) return;
      
      try {
        // 실제 구현에서는 문의 dbId를 찾아서 색상 변경
        // 여기서는 시뮬레이션으로 처리
        console.log(`문 하이라이트: ${door.name}`, door);
        
        // 마커 추가 (실제로는 viewer.impl에서 처리)
        // addMarkerToViewer(door.position, door.name);
      } catch (error) {
        console.error('문 하이라이트 실패:', error);
      }
    }
    
    // 문 이벤트 로그
    function logDoorEvent(door) {
      const event = {
        timestamp: new Date().toISOString(),
        doorId: door.id,
        doorName: door.name,
        action: door.status,
        position: door.position
      };
      
      // 실제로는 서버나 Google Sheets API로 전송
      console.log('문 이벤트 로그:', event);
      
      // 로컬 스토리지에 임시 저장 (실제로는 서버로 전송)
      const events = JSON.parse(localStorage.getItem('doorEvents') || '[]');
      events.push(event);
      localStorage.setItem('doorEvents', JSON.stringify(events));
    }
    
    // 차트 초기화
    function initializeCharts() {
      if (charts.temperature) {
        charts.temperature.destroy();
      }
      if (charts.energy) {
        charts.energy.destroy();
      }
      if (charts.doors) {
        charts.doors.destroy();
      }
      
      // 온도 차트
      const tempCtx = document.getElementById('temperature-chart').getContext('2d');
      charts.temperature = new Chart(tempCtx, {
        type: 'line',
        data: {
          labels: generateTimeLabels('day'),
          datasets: [{
            label: '온도 (°C)',
            data: generateTemperatureData(),
            borderColor: '#49a6ff',
            backgroundColor: 'rgba(73, 166, 255, 0.1)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: '#bfc3ce'
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#8fa0b2'
              },
              grid: {
                color: '#292c31'
              }
            },
            y: {
              ticks: {
                color: '#8fa0b2'
              },
              grid: {
                color: '#292c31'
              }
            }
          }
        }
      });
      
      // 에너지 차트
      const energyCtx = document.getElementById('energy-chart').getContext('2d');
      charts.energy = new Chart(energyCtx, {
        type: 'bar',
        data: {
          labels: generateTimeLabels('day'),
          datasets: [{
            label: '에너지 소비 (kWh)',
            data: generateEnergyData(),
            backgroundColor: '#6c5ecb',
            borderColor: '#6c5ecb',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: '#bfc3ce'
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#8fa0b2'
              },
              grid: {
                color: '#292c31'
              }
            },
            y: {
              ticks: {
                color: '#8fa0b2'
              },
              grid: {
                color: '#292c31'
              }
            }
          }
        }
      });
      
      // 문 상태 차트
      const doorsCtx = document.getElementById('doors-chart').getContext('2d');
      charts.doors = new Chart(doorsCtx, {
        type: 'doughnut',
        data: {
          labels: ['열린 문', '닫힌 문'],
          datasets: [{
            data: [doors.filter(d => d.status === 'open').length, doors.filter(d => d.status === 'closed').length],
            backgroundColor: ['#ff6b6b', '#28a745'],
            borderColor: ['#ff6b6b', '#28a745'],
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: '#bfc3ce'
              }
            }
          }
        }
      });
    }
    
    // 시간 라벨 생성
    function generateTimeLabels(period) {
      const labels = [];
      const now = new Date();
      
      if (period === 'day') {
        for (let i = 23; i >= 0; i--) {
          const time = new Date(now.getTime() - (i * 60 * 60 * 1000));
          labels.push(time.getHours() + ':00');
        }
      } else if (period === 'week') {
        for (let i = 6; i >= 0; i--) {
          const date = new Date(now.getTime() - (i * 24 * 60 * 60 * 1000));
          labels.push(date.toLocaleDateString('ko-KR', { weekday: 'short' }));
        }
      } else if (period === 'month') {
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now.getTime() - (i * 24 * 60 * 60 * 1000));
          labels.push(date.getDate() + '일');
        }
      }
      
      return labels;
    }
    
    // 온도 데이터 생성 (시뮬레이션)
    function generateTemperatureData() {
      const data = [];
      for (let i = 0; i < 24; i++) {
        data.push(20 + Math.sin(i / 4) * 3 + Math.random() * 2);
      }
      return data;
    }
    
    // 에너지 데이터 생성 (시뮬레이션)
    function generateEnergyData() {
      const data = [];
      for (let i = 0; i < 24; i++) {
        data.push(50 + Math.random() * 30 + (i > 8 && i < 18 ? 20 : 0));
      }
      return data;
    }
    
    // 차트 기간 설정
    function setChartPeriod(chartType, period) {
      const buttons = document.querySelectorAll(`.chart-controls .chart-btn`);
      buttons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // 차트 데이터 업데이트
      if (charts[chartType]) {
        charts[chartType].data.labels = generateTimeLabels(period);
        if (chartType === 'temperature') {
          charts[chartType].data.datasets[0].data = generateTemperatureData();
        } else if (chartType === 'energy') {
          charts[chartType].data.datasets[0].data = generateEnergyData();
        }
        charts[chartType].update();
      }
    }
    
    // 통계 새로고침 (Google Sheets 연동)
    function refreshStatistics() {
      showInfo('통계 데이터를 새로고침합니다...');
      
      if (isGoogleSheetsConnected) {
        // Google Sheets에서 실제 데이터 가져오기
        loadStatisticsFromGoogleSheets();
      } else {
        // 시뮬레이션 데이터 사용
        setTimeout(() => {
          updateStatisticsFromSimulation();
          updateChartsWithSimulationData();
          showSuccess('시뮬레이션 데이터로 통계가 업데이트되었습니다.');
        }, 1000);
      }
    }
    
    // Google Sheets에서 통계 데이터 로드
    async function loadStatisticsFromGoogleSheets() {
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${googleSheetsConfig.spreadsheetId}/values/${googleSheetsConfig.sheetName}?key=${googleSheetsConfig.apiKey}`;
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error('Google Sheets 데이터를 가져올 수 없습니다.');
        }
        
        const data = await response.json();
        const rows = data.values || [];
        
        if (rows.length < 2) {
          throw new Error('충분한 데이터가 없습니다.');
        }
        
        // 헤더 제외하고 데이터 처리
        const dataRows = rows.slice(1);
        
        // 최근 데이터로 통계 계산
        const recentData = dataRows.slice(-100); // 최근 100개 데이터
        
        const avgTemp = calculateAverage(recentData, 1); // 온도 열
        const avgHumidity = calculateAverage(recentData, 2); // 습도 열
        const totalEnergy = calculateSum(recentData, 3); // 에너지 열
        const doorEvents = calculateSum(recentData, 4); // 문 이벤트 열
        
        // UI 업데이트
        document.getElementById('avg-temp').textContent = avgTemp.toFixed(1) + '°C';
        document.getElementById('avg-humidity').textContent = Math.round(avgHumidity) + '%';
        document.getElementById('total-energy').textContent = totalEnergy.toLocaleString() + ' kWh';
        document.getElementById('door-events').textContent = doorEvents;
        
        // 차트 업데이트
        updateChartsWithRealData(recentData);
        
        showSuccess('Google Sheets 데이터로 통계가 업데이트되었습니다.');
        
      } catch (error) {
        console.error('Google Sheets 데이터 로드 실패:', error);
        showError('Google Sheets 데이터 로드 실패: ' + error.message);
        
        // 실패 시 시뮬레이션 데이터 사용
        updateStatisticsFromSimulation();
        updateChartsWithSimulationData();
      }
    }
    
    // 평균 계산 헬퍼 함수
    function calculateAverage(data, columnIndex) {
      const values = data.map(row => parseFloat(row[columnIndex]) || 0).filter(v => v > 0);
      return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
    }
    
    // 합계 계산 헬퍼 함수
    function calculateSum(data, columnIndex) {
      return data.reduce((sum, row) => sum + (parseFloat(row[columnIndex]) || 0), 0);
    }
    
    // 실제 데이터로 차트 업데이트
    function updateChartsWithRealData(data) {
      if (charts.temperature) {
        const tempData = data.slice(-24).map(row => parseFloat(row[1]) || 0);
        charts.temperature.data.datasets[0].data = tempData;
        charts.temperature.update();
      }
      
      if (charts.energy) {
        const energyData = data.slice(-24).map(row => parseFloat(row[3]) || 0);
        charts.energy.data.datasets[0].data = energyData;
        charts.energy.update();
      }
      
      if (charts.doors) {
        charts.doors.data.datasets[0].data = [
          doors.filter(d => d.status === 'open').length,
          doors.filter(d => d.status === 'closed').length
        ];
        charts.doors.update();
      }
    }
    
    // 시뮬레이션 데이터로 차트 업데이트
    function updateChartsWithSimulationData() {
      if (charts.temperature) {
        charts.temperature.data.datasets[0].data = generateTemperatureData();
        charts.temperature.update();
      }
      if (charts.energy) {
        charts.energy.data.datasets[0].data = generateEnergyData();
        charts.energy.update();
      }
      if (charts.doors) {
        charts.doors.data.datasets[0].data = [
          doors.filter(d => d.status === 'open').length,
          doors.filter(d => d.status === 'closed').length
        ];
        charts.doors.update();
      }
    }
    
    // Google Sheets에서 통계 데이터 업데이트
    function updateStatisticsFromGoogleSheets() {
      // 이 함수는 loadStatisticsFromGoogleSheets로 대체됨
    }
    
    // 시뮬레이션 데이터로 통계 업데이트
    function updateStatisticsFromSimulation() {
      const avgTemp = (22 + Math.random() * 4).toFixed(1);
      const avgHumidity = Math.floor(55 + Math.random() * 10);
      const totalEnergy = Math.floor(1200 + Math.random() * 100);
      const doorEvents = JSON.parse(localStorage.getItem('doorEvents') || '[]').length;
      
      document.getElementById('avg-temp').textContent = avgTemp + '°C';
      document.getElementById('avg-humidity').textContent = avgHumidity + '%';
      document.getElementById('total-energy').textContent = totalEnergy.toLocaleString() + ' kWh';
      document.getElementById('door-events').textContent = doorEvents;
    }
    
    // Tandem 초기화 함수 (간단화된 버전)
    async function initializeTandem() {
      const connectBtn = document.getElementById('connect-btn');
      const connectText = document.getElementById('connect-text');
      const statusIndicator = document.getElementById('status-indicator');
      
      if (isConnected) {
        showInfo('이미 연결되어 있습니다.');
        return;
      }
      
      try {
        connectText.textContent = '연결 중...';
        
        // 시뮬레이션: 실제로는 Tandem API 연결
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        isConnected = true;
        connectText.textContent = '연결됨';
        connectBtn.classList.add('active');
        statusIndicator.classList.add('connected');
        
        showSuccess('Tandem에 성공적으로 연결되었습니다.');
        
      } catch (error) {
        connectText.textContent = 'Tandem 연결';
        showError('Tandem 연결 실패: ' + error.message);
      }
    }
    
    // 실시간 데이터 업데이트
    async function fetchStatus() {
      try {
        // 시뮬레이션 데이터
        const now = new Date();
        const temp = (20 + Math.sin(now.getMinutes() / 10) * 3).toFixed(1) + '°C';
        const hum = (50 + Math.cos(now.getMinutes() / 8) * 10).toFixed(0) + '%';
        const energy = (Math.random() * 50 + 100).toFixed(1) + 'kWh';
        const illumin = (Math.random() * 200 + 300).toFixed(0) + 'lux';
        
        document.getElementById('temp-value').textContent = temp;
        document.getElementById('hum-value').textContent = hum;
        document.getElementById('energy-value').textContent = energy;
        document.getElementById('illumin-value').textContent = illumin;
        
        // 랜덤하게 문 상태 변경 (시뮬레이션)
        if (Math.random() < 0.1) {
          const randomDoor = doors[Math.floor(Math.random() * doors.length)];
          toggleDoor(randomDoor.id);
        }
        
      } catch (e) {
        console.log('실시간 데이터 업데이트 실패:', e);
      }
    }
    
    // 메시지 표시 함수들
    function showMessage(type, message, duration = 5000) {
      const messageDiv = document.getElementById(`${type}-message`);
      messageDiv.textContent = message;
      messageDiv.style.display = 'block';
      
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, duration);
    }
    
    function showError(message) {
      showMessage('error', message);
    }
    
    function showSuccess(message) {
      showMessage('success', message);
    }
    
    function showInfo(message) {
      showMessage('info', message);
    }
    
    // 초기화 (최종 버전)
    window.addEventListener('load', () => {
      console.log('🚀 Digital Twin Dashboard 초기화 시작...');
      
      // 브라우저 호환성 체크
      if (!checkBrowserCompatibility()) {
        showError('일부 기능이 제한될 수 있습니다. 최신 브라우저 사용을 권장합니다.');
      }
      
      // 기본 초기화
      initializeDoors();
      
      // 자동 저장된 상태 복원
      restoreAutoSavedState();
      
      // Google Sheets API 초기화
      initGoogleSheets();
      
      // 성능 모니터링 시작
      startPerformanceMonitoring();
      
      // 자동 저장 활성화
      enableAutoSave();
      
      // 알림 권한 요청 (5초 후)
      setTimeout(requestNotificationPermission, 5000);
      
      // 페이지 가시성 변경 감지
      document.addEventListener('visibilitychange', handleVisibilityChange);
      
      // 환영 메시지
      showInfo('🎉 Digital Twin Dashboard가 준비되었습니다! F1을 눌러 단축키를 확인하세요.');
      
      // 실시간 데이터 업데이트 시작 (30초마다)
      setInterval(fetchStatus, 30000);
      fetchStatus();
      
      // 문 상태 체크 (10초마다)
      setInterval(() => {
        checkDoorStateChanges();
      }, 10000);
      
      // 초기화 완료 로그
      setTimeout(() => {
        console.log('✅ Digital Twin Dashboard 초기화 완료');
        console.log(`📊 Google Sheets 연동: ${isGoogleSheetsConnected ? '✅ 연결됨' : '❌ 미연결'}`);
        console.log(`🔔 알림 권한: ${Notification.permission}`);
        console.log(`🚪 모니터링 중인 문: ${doors.length}개`);
        console.log(`💾 자동 저장: 활성화됨 (5분 간격)`);
        console.log(`📱 성능 모니터링: 활성화됨`);
        
        // 개발자를 위한 팁
        console.log('\n💡 개발자 팁:');
        console.log('- F1: 키보드 단축키 보기');
        console.log('- 콘솔에서 doors, charts, viewer 변수로 직접 제어 가능');
        console.log('- localStorage에 설정과 상태가 자동 저장됨');
      }, 2000);
    });
  </script>
</body>
</html>